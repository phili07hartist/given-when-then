<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gherkin AC Builder</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for better readability and structure */
        .ac-block.disabled {
            opacity: 0.6;
            pointer-events: none;
            filter: grayscale(80%);
        }
        .recommendation-label {
            transition: background-color 0.15s, transform 0.1s;
        }
        .recommendation-label:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }
        .statement-output {
            min-height: 2.5rem;
        }
    </style>
</head>
<body class="bg-gray-50 antialiased p-4 sm:p-8">
    
    <div class="max-w-4xl mx-auto bg-white rounded-xl shadow-2xl p-6 md:p-10">
        <h1 class="text-3xl font-extrabold text-blue-800 border-b-4 border-blue-400 pb-3 mb-6">
            Gherkin AC Builder
        </h1>
        <p class="text-gray-600 mb-8">
            Define your Acceptance Criteria using sequential component selection. User inputs are saved locally as recommendations.
        </p>

        <!-- Feature Name Input (General AC) -->
        <div class="feature-section mb-8 p-4 bg-blue-50 rounded-lg border border-blue-200">
            <label for="featureName" class="block text-lg font-semibold text-blue-800 mb-2">Feature Name (Optional):</label>
            <input type="text" id="featureName" placeholder="e.g., User Authentication, Shopping Cart Checkout"
                   class="w-full p-3 border-2 border-blue-300 rounded-lg focus:border-blue-500 focus:ring-1 focus:ring-blue-500 transition duration-150"
                   onchange="saveFeatureName()">
        </div>
        
        <!-- Status Message -->
        <div id="status-message" class="hidden p-3 mb-6 text-sm rounded-lg" role="alert"></div>

        <!-- AC Builder Area -->
        <div id="ac-builder">
            
            <!-- GIVEN Block -->
            <div class="ac-block transition-all duration-300" id="given-block">
                <h2 class="text-2xl font-bold text-green-700 mb-3">Given</h2>
                <div id="given-summary" class="summary-display mb-4 p-2 bg-gray-50 rounded-lg border border-gray-200"></div>
                <div class="statement-output text-gray-800 bg-green-50 p-3 mb-4 rounded-lg border-l-4 border-green-500 font-mono italic">
                    Given [Entry] [Subject] [State]
                </div>
                <div class="input-section space-y-4" data-clause="Given">
                    <!-- Components are generated by JS but placeholders are here for structure -->
                    <div class="input-component" data-key="Entry"></div>
                    <div class="input-component hidden" data-key="Subject"></div>
                    <div class="input-component hidden" data-key="State"></div>

                    <div class="action-buttons pt-4 flex flex-wrap gap-3">
                        <button class="commit-btn hidden px-4 py-2 bg-green-500 text-white font-semibold rounded-lg shadow-md hover:bg-green-600 transition duration-150" data-clause="Given">
                            Add additional Given condition
                        </button>
                        <button class="next-btn hidden px-4 py-2 bg-yellow-500 text-white font-semibold rounded-lg shadow-md hover:bg-yellow-600 transition duration-150" data-target="When" data-clause="Given">
                            Move to When &rarr;
                        </button>
                    </div>
                </div>
            </div>

            <!-- WHEN Block -->
            <div class="ac-block transition-all duration-300 disabled mt-8 pt-6 border-t border-gray-200" id="when-block">
                <h2 class="text-2xl font-bold text-yellow-700 mb-3">When</h2>
                <div id="when-summary" class="summary-display mb-4 p-2 bg-gray-50 rounded-lg border border-gray-200"></div>
                <div class="statement-output text-gray-800 bg-yellow-50 p-3 mb-4 rounded-lg border-l-4 border-yellow-500 font-mono italic">
                    When [Result] [Verb] [Subject]
                </div>
                <div class="input-section space-y-4 hidden" data-clause="When">
                    <div class="input-component" data-key="Result"></div>
                    <div class="input-component hidden" data-key="Verb"></div>
                    <div class="input-component hidden" data-key="Subject"></div>

                    <div class="action-buttons pt-4 flex flex-wrap gap-3">
                        <button class="commit-btn hidden px-4 py-2 bg-green-500 text-white font-semibold rounded-lg shadow-md hover:bg-green-600 transition duration-150" data-clause="When">
                            Add additional When condition
                        </button>
                        <button class="next-btn hidden px-4 py-2 bg-red-500 text-white font-semibold rounded-lg shadow-md hover:bg-red-600 transition duration-150" data-target="Then" data-clause="When">
                            Move to Then &rarr;
                        </button>
                    </div>
                </div>
            </div>

            <!-- THEN Block -->
            <div class="ac-block transition-all duration-300 disabled mt-8 pt-6 border-t border-gray-200" id="then-block">
                <h2 class="text-2xl font-bold text-red-700 mb-3">Then</h2>
                <div id="then-summary" class="summary-display mb-4 p-2 bg-gray-50 rounded-lg border border-gray-200"></div>
                <div class="statement-output text-gray-800 bg-red-50 p-3 mb-4 rounded-lg border-l-4 border-red-500 font-mono italic">
                    Then [Exit] [Verb] [Interpretation]
                </div>
                <div class="input-section space-y-4 hidden" data-clause="Then">
                    <div class="input-component" data-key="Exit"></div>
                    <div class="input-component hidden" data-key="Verb"></div>
                    <div class="input-component hidden" data-key="Interpretation"></div>

                    <div class="action-buttons pt-4 flex flex-wrap gap-3">
                        <button class="commit-btn hidden px-4 py-2 bg-green-500 text-white font-semibold rounded-lg shadow-md hover:bg-green-600 transition duration-150" data-clause="Then">
                            Add additional Then condition
                        </button>
                        <button class="complete-btn hidden px-4 py-2 bg-indigo-600 text-white font-semibold rounded-lg shadow-md hover:bg-indigo-700 transition duration-150">
                            Complete AC Statement
                        </button>
                    </div>
                </div>
            </div>
            
        </div>

        <hr class="my-10 border-gray-300">
        
        <!-- Final Output -->
        <div class="final-output">
            <h3 class="text-2xl font-bold text-gray-800 mb-4 flex items-center">
                <svg class="w-6 h-6 mr-2 text-indigo-600" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path></svg>
                Final Acceptance Criteria
            </h3>
            <pre id="final-ac-output" class="bg-gray-100 p-4 rounded-lg border-2 border-dashed border-indigo-300 text-base font-mono whitespace-pre-wrap">Start building your Acceptance Criteria above.</pre>
        </div>

    </div>

    <script>
        // --- 1. DATA STRUCTURES ---

        const PREDEFINED_DATA = {
            Given: {
                Entry: ['A', 'An', 'I am', 'I am not', 'One or more', 'Zero or less', 'Another', 'The'],
                Subject: ['Admin', 'Non-admin', 'User'],
                State: ['Exist', 'Do not exist']
            },
            When: {
                Result: ['successfully', 'unsuccessfully'],
                Verb: ['View', 'Provide', 'Remove', 'Add'],
                Subject: ['Admin', 'Non-admin', 'User']
            },
            Then: {
                Exit: ['I can', 'I cannot'],
                Verb: ['see', 'understand', 'identify'],
                Interpretation: ['how much medicine is required']
            }
        };

        const CLAUSE_COMPONENTS = {
            Given: ['Entry', 'Subject', 'State'],
            When: ['Result', 'Verb', 'Subject'],
            Then: ['Exit', 'Verb', 'Interpretation']
        };

        // Define which components are MANDATORY for successful commitment
        const MANDATORY_COMPONENTS = {
            Given: ['Entry'],
            When: ['Result', 'Verb', 'Subject'],
            Then: ['Exit', 'Verb', 'Interpretation']
        };

        // Stores the currently built statement parts for the active clause (e.g., Given: {Entry: 'The'})
        let currentStatementParts = { Given: {}, When: {}, Then: {} };
        // Stores committed, final criteria lines (e.g., Given: ['The horse is sick'])
        let committedCriteria = { Given: [], When: [], Then: [] };
        
        const featureNameInput = document.getElementById('featureName');
        const finalOutput = document.getElementById('final-ac-output');
        const statusMessage = document.getElementById('status-message');


        // --- 2. LOCAL STORAGE HANDLING ---

        function loadLocalRecommendations() {
            try {
                const stored = localStorage.getItem('gherkin_ac_recommendations');
                return stored ? JSON.parse(stored) : {};
            } catch (e) {
                console.error("Error parsing local storage recommendations. Resetting.", e);
                return {};
            }
        }

        function saveLocalRecommendation(clause, key, value) {
            let recommendations = loadLocalRecommendations();
            if (!recommendations[clause]) recommendations[clause] = {};
            if (!recommendations[clause][key]) recommendations[clause][key] = [];
            
            // Ensure value is a string before proceeding
            const stringValue = String(value).trim();
            if (!stringValue) return;

            // Prevent duplicates and ensure 'item' is a string before calling toLowerCase()
            const isDuplicate = recommendations[clause][key].some(
                (item) => typeof item === 'string' && item.toLowerCase() === stringValue.toLowerCase()
            );

            if (!isDuplicate) {
                // Store the new input
                recommendations[clause][key].push(stringValue); 
                localStorage.setItem('gherkin_ac_recommendations', JSON.stringify(recommendations));
            }
        }

        function loadFeatureName() {
            const storedName = localStorage.getItem('gherkin_feature_name') || '';
            featureNameInput.value = storedName;
        }

        function saveFeatureName() {
            localStorage.setItem('gherkin_feature_name', featureNameInput.value.trim());
            showStatus('Feature name saved locally.', 'bg-blue-100 text-blue-800');
        }

        function getAllRecommendations(clause, key) {
            const local = loadLocalRecommendations();
            let localRecs = (local[clause] && local[clause][key]) || [];
            
            localRecs = localRecs.filter(item => typeof item === 'string');

            const predefined = PREDEFINED_DATA[clause][key] || [];
            
            const combined = [...new Set([...predefined, ...localRecs])];

            return combined;
        }


        // --- 3. UI RENDERING & LOGIC ---

        function showStatus(message, classes) {
            statusMessage.textContent = message;
            statusMessage.className = `p-3 mb-6 text-sm rounded-lg ${classes}`;
            statusMessage.classList.remove('hidden');
            setTimeout(() => {
                statusMessage.classList.add('hidden');
            }, 3000);
        }
        
        // Renders the summary of committed criteria for a clause
        function renderCommittedSummary(clause) {
            const container = document.getElementById(`${clause.toLowerCase()}-summary`);
            if (!container) return;

            if (committedCriteria[clause].length === 0) {
                container.innerHTML = `<p class="text-sm text-gray-500 italic">No committed ${clause} criteria yet.</p>`;
                return;
            }

            container.innerHTML = committedCriteria[clause].map((statement, index) => {
                const prefix = index === 0 ? clause : 'And';
                // Filter out multiple spaces that might result from skipped optional fields
                const cleanStatement = statement.replace(/\s+/g, ' ').trim();
                return `<p class="text-sm font-mono text-gray-700">${prefix} ${cleanStatement}</p>`;
            }).join('');
        }

        // Renders the input structure for a component (Entry, Subject, etc.)
        function renderComponentInput(clause, key) {
            const componentContainer = document.querySelector(`.input-section[data-clause="${clause}"] .input-component[data-key="${key}"]`);
            
            // Clear existing content, keeping only the label/input skeleton
            componentContainer.innerHTML = `
                <label class="block text-sm font-medium text-gray-700 mb-1">${key} ${MANDATORY_COMPONENTS[clause].includes(key) ? '<span class="text-red-500">*</span>' : ''}</label>
                <input type="text" placeholder="Type or Select ${key}${!MANDATORY_COMPONENTS[clause].includes(key) ? ' (Optional)' : ''}" 
                       data-clause="${clause}" data-key="${key}"
                       class="w-full p-2 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500 shadow-sm mb-2">
                <div class="recommendations flex flex-wrap gap-2"></div>
            `;
            
            const inputElement = componentContainer.querySelector('input');
            inputElement.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' || e.key === 'Tab') {
                    e.preventDefault();
                    // Get the trimmed value. If optional, it can be empty string.
                    const value = inputElement.value.trim(); 
                    handleNextComponent(clause, key, value);
                }
            });

            // Add Go Back button if not the first component in the clause
            if (CLAUSE_COMPONENTS[clause].indexOf(key) > 0) {
                const backButton = document.createElement('button');
                backButton.className = 'go-back-btn text-sm text-blue-600 hover:text-blue-800 font-semibold mt-2';
                backButton.textContent = '← Go Back';
                backButton.addEventListener('click', () => {
                    handleGoBack(clause, key);
                });
                componentContainer.appendChild(backButton);
            }
            
            // Add Skip button if element is non-mandatory
            if (!MANDATORY_COMPONENTS[clause].includes(key)) {
                const skipButton = document.createElement('button');
                skipButton.className = 'skip-btn text-sm text-yellow-600 hover:text-gray-800 font-semibold mt-2 ml-4';
                skipButton.textContent = 'Skip →';
                skipButton.addEventListener('click', () => {
                    handleNextComponent(clause, key, ''); // Pass empty string to indicate skip
                });
                componentContainer.appendChild(skipButton);
            }

            renderRecommendations(clause, key, componentContainer.querySelector('.recommendations'));
        }

        function renderRecommendations(clause, key, container) {
            container.innerHTML = '';
            
            const recs = getAllRecommendations(clause, key);

            recs.forEach(rec => {
                const label = document.createElement('span');
                label.className = 'recommendation-label px-3 py-1 bg-gray-200 text-gray-700 text-sm rounded-full cursor-pointer hover:bg-blue-500 hover:text-white transition duration-150';
                label.textContent = rec;
                label.setAttribute('data-value', rec);
                
                label.addEventListener('click', () => {
                    const input = document.querySelector(`.input-section[data-clause="${clause}"] .input-component[data-key="${key}"] input`);
                    input.value = rec;
                    handleNextComponent(clause, key, rec);
                });
                container.appendChild(label);
            });
        }

        // Updates the current statement display (e.g., Given The [Subject] [State])
        function updateStatementOutput(clause) {
            const outputElement = document.querySelector(`#${clause.toLowerCase()}-block .statement-output`);
            const parts = CLAUSE_COMPONENTS[clause].map(key => {
                // Use stored value, if present, otherwise use a placeholder
                const part = currentStatementParts[clause][key];
                return (part !== undefined && part !== '') ? part : `[${key}]`;
            }).join(' ');
            
            const prefix = committedCriteria[clause].length > 0 ? 'And' : clause;
            outputElement.textContent = `${prefix} ${parts}`;
        }

        // Moves to the next component within the current clause
        function handleNextComponent(clause, currentKey, value) {
            const components = CLAUSE_COMPONENTS[clause];
            const currentIndex = components.indexOf(currentKey);
            
            // 1. Store the value. If empty and optional, store empty string. If empty and mandatory, block.
            currentStatementParts[clause][currentKey] = value;
            
            // 1b. Validate Mandatory fields before moving
            const isMandatory = MANDATORY_COMPONENTS[clause].includes(currentKey);

            if (!value.trim() && isMandatory) {
                showStatus(`The '${currentKey}' field is mandatory for the ${clause} clause.`, 'bg-red-100 text-red-800');
                // Ensure the part is correctly represented as empty in the display
                currentStatementParts[clause][currentKey] = ''; 
                updateStatementOutput(clause);
                return; 
            }

            // Save non-empty strings to local storage for recommendations
            if (value.trim()) {
                saveLocalRecommendation(clause, currentKey, value);
            }

            updateStatementOutput(clause);
            
            // 2. Hide current component
            document.querySelector(`.input-component[data-key="${currentKey}"]`).classList.add('hidden');

            // 3. Check for next component
            const nextIndex = currentIndex + 1;
            if (nextIndex < components.length) {
                const nextKey = components[nextIndex];
                const nextComponent = document.querySelector(`.input-section[data-clause="${clause}"] .input-component[data-key="${nextKey}"]`);
                
                // Show and focus the next component
                nextComponent.classList.remove('hidden');
                
                // Re-render to ensure back button and fresh recommendations are available
                renderComponentInput(clause, nextKey);

                // Set focus
                nextComponent.querySelector('input').value = '';
                nextComponent.querySelector('input').focus();
            } else {
                // End of clause components - show Commit/Next buttons
                const section = document.querySelector(`.input-section[data-clause="${clause}"]`);
                section.querySelector('.commit-btn').classList.remove('hidden');
                
                if (clause !== 'Then') {
                    section.querySelector('.next-btn').classList.remove('hidden');
                } else {
                    section.querySelector('.complete-btn').classList.remove('hidden');
                }
            }
        }
        
        // Handles the Go Back action
        function handleGoBack(clause, currentKey) {
            const components = CLAUSE_COMPONENTS[clause];
            const currentIndex = components.indexOf(currentKey);
            
            if (currentIndex <= 0) return; // Cannot go back from the first element

            const prevKey = components[currentIndex - 1];
            
            // 1. Clear the values for the current and previous component from parts
            currentStatementParts[clause][currentKey] = '';
            currentStatementParts[clause][prevKey] = '';

            // 2. Update display output
            updateStatementOutput(clause);

            // 3. Hide current component and action buttons
            const currentComponent = document.querySelector(`.input-component[data-key="${currentKey}"]`);
            currentComponent.classList.add('hidden');
            
            const inputSection = document.querySelector(`.input-section[data-clause="${clause}"]`);
            inputSection.querySelector('.commit-btn').classList.add('hidden');
            inputSection.querySelector('.next-btn')?.classList.add('hidden');
            inputSection.querySelector('.complete-btn')?.classList.add('hidden');

            // 4. Show and focus previous component
            const prevComponent = document.querySelector(`.input-component[data-key="${prevKey}"]`);
            prevComponent.classList.remove('hidden');
            
            // Re-render and clear the input field (since we cleared the value in currentStatementParts)
            renderComponentInput(clause, prevKey); 
            prevComponent.querySelector('input').value = ''; 
            prevComponent.querySelector('input').focus();
            
            showStatus(`Moved back to select ${prevKey}. Previous input discarded.`, 'bg-gray-100 text-gray-700');
        }

        // Commits the current statement as a completed criteria
        function commitCriteria(clause) {
            
            // 1. Check if all mandatory parts are filled in currentStatementParts
            const isMandatoryMissing = MANDATORY_COMPONENTS[clause].some(key => {
                // Check if the mandatory key is missing or is an empty string after trimming
                return !currentStatementParts[clause][key] || currentStatementParts[clause][key].trim() === '';
            });
            
            if (isMandatoryMissing) {
                showStatus(`Please ensure all mandatory parts for the ${clause} clause are filled.`, 'bg-red-100 text-red-800');
                return;
            }

            // 2. Build statement, filtering out empty (skipped) parts
            const statementParts = CLAUSE_COMPONENTS[clause]
                .map(key => currentStatementParts[clause][key])
                .filter(part => part && part.trim() !== ''); // Filter out empty strings
            
            const statement = statementParts.join(' ');

            committedCriteria[clause].push(statement);
            
            // Update Final Output
            updateFinalACOutput();
            renderCommittedSummary(clause);

            // Reset for additional criteria
            currentStatementParts[clause] = {};
            
            // Reset UI to the first component
            const inputSection = document.querySelector(`.input-section[data-clause="${clause}"]`);
            inputSection.querySelectorAll('.input-component').forEach(comp => comp.classList.add('hidden'));
            
            const firstKey = CLAUSE_COMPONENTS[clause][0];
            const firstComponent = inputSection.querySelector(`.input-component[data-key="${firstKey}"]`);
            
            // Re-render and show the first component
            renderComponentInput(clause, firstKey);
            firstComponent.classList.remove('hidden');
            
            updateStatementOutput(clause); // Reset temporary output line
            
            // Hide action buttons
            inputSection.querySelector('.commit-btn').classList.add('hidden');
            inputSection.querySelector('.next-btn')?.classList.add('hidden');
            inputSection.querySelector('.complete-btn')?.classList.add('hidden');
            
            showStatus(`${clause} criteria successfully committed. Add another or move to the next clause.`, 'bg-green-100 text-green-800');
        }

        // Builds and displays the final Gherkin statement
        function updateFinalACOutput() {
            let acText = '';
            
            const featureName = featureNameInput.value.trim() || 'Untitled Feature';
            const hasCriteria = committedCriteria.Given.length > 0 || committedCriteria.When.length > 0 || committedCriteria.Then.length > 0;

            if (hasCriteria) {
                acText += `Feature: ${featureName}\n\nScenario: Acceptance Criteria\n`;
            }

            if (committedCriteria.Given.length > 0) {
                acText += `  Given ${committedCriteria.Given[0]}`;
                for (let i = 1; i < committedCriteria.Given.length; i++) {
                    acText += `\n  And ${committedCriteria.Given[i]}`;
                }
            }

            if (committedCriteria.When.length > 0) {
                if (acText && committedCriteria.Given.length > 0) acText += `\n`; 
                acText += `  When ${committedCriteria.When[0]}`;
                for (let i = 1; i < committedCriteria.When.length; i++) {
                    acText += `\n  And ${committedCriteria.When[i]}`;
                }
            }

            if (committedCriteria.Then.length > 0) {
                if (acText && (committedCriteria.Given.length > 0 || committedCriteria.When.length > 0)) acText += `\n`; 
                acText += `  Then ${committedCriteria.Then[0]}`;
                for (let i = 1; i < committedCriteria.Then.length; i++) {
                    acText += `\n  And ${committedCriteria.Then[i]}`;
                }
            }
            
            if (hasCriteria) {
                 finalOutput.textContent = acText.trim();
            } else {
                 finalOutput.textContent = "Start building your Acceptance Criteria above.";
            }
        }

        // --- 4. INITIALIZATION AND EVENT LISTENERS ---

        function init() {
            loadFeatureName();

            // 1. Initialize all component inputs for all clauses
            Object.keys(CLAUSE_COMPONENTS).forEach(clause => {
                CLAUSE_COMPONENTS[clause].forEach(key => {
                    renderComponentInput(clause, key);
                });
                renderCommittedSummary(clause); // Initialize empty summaries
            });

            // 2. Initialize the first input component for Given (Entry)
            document.querySelector('.ac-block#given-block .input-section').classList.remove('hidden');
            document.querySelector('.ac-block#given-block .input-component[data-key="Entry"]').classList.remove('hidden');
            updateStatementOutput('Given');

            // 3. Event listener for moving between clauses
            document.querySelectorAll('.next-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const currentClause = e.currentTarget.dataset.clause;
                    const targetClause = e.currentTarget.dataset.target;
                    
                    if (!currentClause || !targetClause) {
                         console.error("Button clicked without required data attributes. Skipping transition.");
                         return;
                    }

                    // Disable current block
                    document.getElementById(`${currentClause.toLowerCase()}-block`).classList.add('disabled');
                    
                    // Enable next block
                    const nextBlock = document.getElementById(`${targetClause.toLowerCase()}-block`);
                    nextBlock.classList.remove('disabled');
                    
                    const nextInputSection = nextBlock.querySelector('.input-section');
                    nextInputSection.classList.remove('hidden');
                    
                    // Initialize the first component of the next clause
                    const firstKey = CLAUSE_COMPONENTS[targetClause][0];
                    const firstComponent = nextInputSection.querySelector(`.input-component[data-key="${firstKey}"]`);

                    firstComponent.classList.remove('hidden');
                    renderComponentInput(targetClause, firstKey); // Re-render for fresh state and back button
                    
                    firstComponent.querySelector('input').focus();
                    updateStatementOutput(targetClause);

                    nextBlock.scrollIntoView({ behavior: 'smooth', block: 'start' });
                });
            });

            // 4. Event listener for Commit button
            document.querySelectorAll('.commit-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    commitCriteria(e.currentTarget.dataset.clause);
                });
            });

            // 5. Final AC Completion button
            document.querySelector('.complete-btn').addEventListener('click', () => {
                commitCriteria('Then'); // Commit the final 'Then' line before completion
                showStatus('Acceptance Criteria statement completed!', 'bg-indigo-100 text-indigo-800');
            });

            updateFinalACOutput();
        }

        init();
    </script>
</body>
</html>